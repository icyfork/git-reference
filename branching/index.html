---
layout: reference
---

<div class="box">
  <h2>
    <span class="docs">
      <a target="new" href="http://progit.org/book/ch3-0.html">book</a>
    </span>
    Rẽ nhánh và Trộn
  </h2>
  <div class="block">
    <p>Rẽ nhánh là một trong các tính năng tôi thích của Git.
    Khi làm việc với Git, bạn nên tạm quên đi khái niệm nhánh
    mà bạn từng biết trong các hệ thống quản lý phiên bản khác,
    vì thực tế, mỗi nhánh trong Git gần giống như một <i>ngữ cảnh</i>.
    Việc rẽ vào một nhánh tương tự việc chuyển qua ngữ cảnh làm việc mới,
    và sau đó có thể nhanh chóng quay lại ngữ cảnh cũ.
    </p>

    <p>
    ND: Việc rẽ nhánh giống như việc đang đi trên đường thì bạn muốn
    rẽ sang ngã khác (ngã ba, ngã tư chẳng hạn), để thực hiện một số
    việc như thăm người quen, tránh kẹt xe, rồi quay trở lại đường
    chính sau. Một nhánh trong Git gần như một đoạn đường hoặc con đường.
    Nếu các con đường ở Sài Gòn đã cố định, thì con đường trong Git
    dễ chịu hơn mà bạn có thể tạo ra bất kỳ lúc nào :)</p>

    <p class="nutshell">
    <b>Tóm tắt:</b> bạn tạo ra một nhánh mới bằng
            <code>git branch tên_nhánh</code>,
    sau đó rẽ vào nhánh đó bằng
            <code>git checkout tên_nhánh</code>;
    sau lưu lại các thay đổi trong ngữ cảnh này, bạn có thể rẽ qua nhánh
    khác một cách dễ dàng.

    Mỗi khi rẽ vào một nhánh, Git sẽ thay thư mục làm việc cho tương ứng
    với nhánh đó; vì vậy, bạn không phải xử lý nhiều thư mục khác nhau
    cho nhiều nhánh (có nghĩa là, chỉ dùng một thư mục cho nhiều nhánh. Điều
    này rất khác với cách tiếp cận của Subversion -- ND). Cuối cùng, để
    trộn hai nhánh với nhau, dùng <code>git merge</code>. Có thể dễ dàng
    trộn nhiều lần hai nhánh với nhau, hoặc có thể xóa một nhánh sau khi
    nó đã được trộn.
    </p>

  </div>
</div>

<div class="box">
  <h2>
    <span class="docs">
      <a target="new" href="http://www.kernel.org/pub/software/scm/git/docs/git-branch.html">docs</a> &nbsp;
      <a target="new" href="http://progit.org/book/ch3-2.html">book</a>
    </span>
    <a name="branch">git branch</a>
    <span class="desc">liệt kê, tạo, quản lý các nhánh</span>
  </h2>

  <br/>

  <h2>
    <span class="docs">
      <a target="new" href="http://www.kernel.org/pub/software/scm/git/docs/git-checkout.html">docs</a> &nbsp;
      <a target="new" href="http://progit.org/book/ch3-2.html">book</a>
    </span>
    <a name="checkout">git checkout</a>
    <span class="desc">rẽ vào một nhánh</span>
  </h2>

  <div class="block">
    <p>Lệnh <code>git branch</code> là để quản lý các nhánh; nó có thể
    làm nhiều việc khác nhau, nên chúng ta chỉ để cập một số việc cơ bản
    của lệnh này: liệt kê, tạo hoặc xóa nhánh. Ta cũng đề cập tới lệnh
      <code>git checkout</code>
    để rẽ vào một nhánh bất kỳ.
    </p>

    <h4>
      git branch
      <small>liệt kê các nhánh</small>
    </h4>

    <p>Khi không có tham số, <code>git branch</code> sẽ liệt kê các nhánh
    sẵn có, riêng nhánh bạn đang rẽ vào được đánh dấu sao <b>*</b> hoặc
      <a href="http://progit.org/book/ch7-1.html#colors_in_git">tô màu xanh lá</a>).
    </p>

<pre>
$ git branch
* <span class="green">master</span>
</pre>

    <p>Cho biết bạn đang rẽ vào nhánh 'master'. Đó là nhánh được tạo ra
    tự động khi bạn khởi tạo kho bằng lệnh <code>git init</code>. Cái tên
    'master' không phải là bắt buộc, nhưng nó được hầu hết dự án dùng do
    sự lựa chọn mặc định của Git.
    </p>

    <h4>
      git branch tên_nhánh
      <small>tạo một nhánh mới</small>
    </h4>

    <p>Bây gờ, ta thử tạo một nhánh mới rồi rẽ vào nhánh đó.

<pre>
$ git branch testing
$ git branch
* <span class="green">master</span>
  testing
</pre>

    <p>Như bạn thấy, sau khi tạo ta sẽ thấy thêm nhánh mới khi liệt kê.
    Nhánh mới tạo ra sẽ chứa những thay đổi cuối cùng đã xác nhận. Vì thế,
    sau thời điểm nhánh 'testing' được tạo ra, bạn xác nhận các thay đổi
    mới (sẽ diễn ra ở nhánh 'master'), rồi lại rẽ vào nhánh 'testing',
    thì thư mục làm việc sẽ trở lại trạng thái ngay trước khi nhánh đó
    đuợc tạo ra (nghĩa là nó sẽ không chứa các thay đổi bạn vừa xác nhận).
    Như vậy, nhánh giống như các đánh dấu trên đường đi cho biết bạn đang
    ở đâu. Ta hãy xem việc rẽ nhánh sẽ diễn ra thế nào, với lệnh
        <code>git checkout tên nhánh</code>
    </p>

<pre>
<b>$ ls</b>
README   hello.rb
<b>$ echo 'test content' > test.txt</b>
<b>$ echo 'more content' > more.txt</b>
<b>$ git add *.txt</b>
<b>$ git commit -m 'added two files'</b>
[master 8bd6d8b] added two files
 2 files changed, 2 insertions(+), 0 deletions(-)
 create mode 100644 more.txt
 create mode 100644 test.txt
<b>$ ls</b>
README   hello.rb more.txt test.txt
<b>$ git checkout testing</b>
Switched to branch 'testing'
<b>$ ls</b>
README   hello.rb
</pre>

    <p>Bây giờ, ta rẽ vào nhánh 'testing'. Bạn sẽ thấy các tập tin vừa tạo
    ra ở trên sẽ bị xóa đi, nhưng chúng sẽ xuất hiện trở lại khi bạn quay
    lại nhánh ban đầu 'master'.</p>

<pre>
<b>$ ls</b>
README   hello.rb
<b>$ git checkout master</b>
Switched to branch 'master'
<b>$ ls</b>
README   hello.rb more.txt test.txt
</pre>

    <h4>
      git checkout -b tên_nhánh
      <small>tạo một nhánh và rẽ ngay vào nhánh đó</small>
    </h4>

    <p>
    Trong nhiều trường hợp bạn muốn rẽ vào một nhánh ngay sau khi nhánh
    đó được tạo ra. Thay vì phải dùng cặp lệnh
      <code>git branch tên_nhán; git checkout tên_nhánh</code>,
    bạn chỉ gõ tắt
      <code>git checkout -b tên_nhánh</code>.
    </p>

<pre>
<b>$ git branch</b>
* master
<b>$ ls</b>
README   hello.rb more.txt test.txt
<b>$ git checkout -b removals</b>
Switched to a new branch 'removals'
<b>$ git rm more.txt </b>
rm 'more.txt'
<b>$ git rm test.txt </b>
rm 'test.txt'
<b>$ ls</b>
README   hello.rb
<b>$ git commit -am 'removed useless files'</b>
[removals 8f7c949] removed useless files
 2 files changed, 0 insertions(+), 2 deletions(-)
 delete mode 100644 more.txt
 delete mode 100644 test.txt
<b>$ git checkout master</b>
Switched to branch 'master'
<b>$ ls</b>
README   hello.rb more.txt test.txt
</pre>

    <p>Như thấy ở trên, ta rẽ vào nhánh 'removals' ngay sau khi tạo ra nhánh
    đó; trong nhánh này, ta thực hiện xóa bớt một số tập tin, xác nhận việc
    xóa và rồi quay lại nhánh chính 'master', ở đó các tập tin vừa xóa sẽ
    xuất hiện trở lại. Như vậy, việc rẽ nhánh hiểu và phân chia thư mục
    làm việc theo đúng ngữ cảnh được chỉ định; việc chuyển đổi giữa các
    nhánh không làm mất đi tập tin hoặc không gây ra nhầm lẫn.</p>

    <p>
    Khi bắt đầu một dự án, bạn nên rẽ vào một nhánh riêng của dự án đó
    (việc này cũng nhanh và dễ), và sau đó trộn nhánh của bạn với nhánh
    chính của dự án; sau khi trộn thì có thể xóa nhánh riêng bạn tạo ra.
    Bằng cách đó, bạn dễ dàng chuyển qua phiên bản (nhánh) ổn định của dự
    án khi xảy ra vấn đề trên nhánh bạn phát triển; hơn nữa, bạn cũng có thể
    dễ dàng tạm gác lại công việc của bạn trên nhánh riêng, để quay trở lại
    các nhánh cũ do yêu cầu bắt buộc của dự án.</p>

    <h4>
      git branch -d tên_nhánh
      <small>xóa một nhánh</small>
    </h4>

    <p>Để xóa một nhánh, bạn chỉ việc dùng lệnh
      <code>git branch -d tên_nhánh</code>. Ví dụ, ta sẽ xóa nhánh
      'testing' đã tạo ra ở ví dụ ở trên.

<pre>
<b>$ git branch</b>
* <span class="green">master</span>
  testing
<b>$ git branch -d testing</b>
Deleted branch testing (was 78b2670).
<b>$ git branch</b>
* <span class="green">master</span>
</pre>

    <p class="nutshell">
    <b>Tóm tắt:</b> bạn dùng <code>git branch</code> để liệt kê các nhánh
    hiện có, rẽ nhánh mới hoặc xóa đi các nhánh đã trộn hoặc không còn cần thiết.
    </p>

  </div>
</div>

<div class="box">
  <h2>
    <span class="docs">
      <a target="new" href="http://www.kernel.org/pub/software/scm/git/docs/git-merge.html">tài liệu</a> &nbsp;
      <a target="new" href="http://progit.org/book/ch3-2.html#basic_merging">sách</a>
    </span>
    <a name="merge">git merge</a>
    <span class="desc">trộn một nhánh vào nhánh đang làm việc</span>
  </h2>

  <div class="block">
    <p>Sau khi chia công việc riêng ra từng nhánh, có lúc bạn sẽ cần trộn
    các nhánh với nhau, hoặc với nhánh chính. Để trộn, bạn dùng lệnh
      <code>git merge</code>.
    Xét ví dụ ở trên với nhánh 'removals'. Ta nhớ lại rằng sau khi rẽ vào
    nhánh 'removals', ta xóa đi một vài tập tin và xác nhận sự thay đổi.
    Việc xóa tập tin này chỉ diễn ra ở nhánh 'removals', còn ở nhánh chính
    'master' không có tập tin nào được xóa. Bây giờ, để xác nhận rằng cả
    các tập tin bị xóa trong 'removals' cũng bị xóa trong 'master', ta chỉ
    việc trộn nhánh 'removals' với 'master'.
    </p>

<pre>
<b>$ git branch</b>
* <span class="green">master</span>
  removals
<b>$ ls</b>
README   hello.rb more.txt test.txt
<b>$ git merge removals</b>
Updating 8bd6d8b..8f7c949
Fast-forward
 more.txt |    1 -
 test.txt |    1 -
 2 files changed, 0 insertions(+), 2 deletions(-)
 delete mode 100644 more.txt
 delete mode 100644 test.txt
<b>$ ls</b>
<span class="hl">README   hello.rb</span>
</pre>

    <h4>
      các phép trộn phức tạp hơn
    </h4>

    <p>Tất nhiên, quá trình phát triển của mã nguồn không chỉ đơn giản
    là thêm và xóa tập tin :). Git còn hỗ trợ thêm việc trộn các thay đổi
    (hoặc sự khác biệt) giữa của tập tin ở hai nhánh khác nhau.
    Lấy ví dụ, ta sẽ chỉnh nội dung tập tin ở một nhánh, trong khi ở nhánh
    kia ta đổi tên tập tin, rồi rồi trộn hai tập tin đó với nhau. Nghe
    có vẻ rối đây! Xem Git giải quyết thế nào nhé!
    </p>

<pre>
<b>$ git branch</b>
* master
<b>$ cat hello.rb </b>
class HelloWorld
  def self.hello
    puts "Hello World"
  end
end

HelloWorld.hello
</pre>

    <p>Bây giờ ta đang ở nhánh 'master'. Ta sẽ tạo nhánh 'change_class'
    và rẽ ngay vào nhánh đó: trong nhánh mới ta sẽ thực hiện đổi tên lớp
    từ 'HelloWorld' dthành 'HiWorld'.</p>

<pre>
<b>$ git checkout -b change_class</b>
M hello.rb
Switched to a new branch 'change_class'
<b>$ vim hello.rb </b>
<b>$ head -1 hello.rb </b>
class HiWorld
<b>$ git commit -am 'changed the class name'</b>
[change_class 3467b0a] changed the class name
 1 files changed, 2 insertions(+), 4 deletions(-)
</pre>

    <p>Việc đổi tên lớp được xác nhận sau lệnh <code>git commit</code>.
      Ta sẽ trở lại nhánh chính 'master' và sẽ thấy rằng trong tên lớp
      vẫn là 'HelloWorld' (như cũ!). Ta sẽ đổi xem có sự khác biệt nào
      với thay đổi đã thực hiện ở nhánh 'change_class', đồng thời đổi tên
      tập tin từ <code>hello.rb</code> thành <code>ruby.rb</code>.
      </b>

<pre>
<b>$ git checkout master</b>
Switched to branch 'master'
<b>$ git mv hello.rb ruby.rb</b>
<b>$ vim ruby.rb </b>
<b>$ git diff</b>
<span class="umber">diff --git a/ruby.rb b/ruby.rb
index 2aabb6e..bf64b17 100644
--- a/ruby.rb
+++ b/ruby.rb</span>
<span class="lblue">@@ -1,7 +1,7 @@</span>
 class HelloWorld

   def self.hello
<span class="red">-    puts "Hello World"</span>
<span class="green">+    puts "Hello World from Ruby"</span>
   end

 end
<b>$ git commit -am 'added from ruby'</b>
[master b7ae93b] added from ruby
 1 files changed, 1 insertions(+), 1 deletions(-)
 rename hello.rb => ruby.rb (65%)
</pre>

    <p>Như ban thấy, sự thay đổi tên tập tin và nội dung cũng vừa được
      xác nhận trong nhánh 'master'. Để ý rằng, tên lớp vẫn là 'HelloWorld'.
      Nếu muốn thay đổi cả tên của lớp thành 'HiWorld', ta chỉ việc trộn
      nội dung ở nhánh 'change_class' vào nhánh 'master'. Nhưng liệu Git
      có trộn được không, vì tên tập tin đã đổi? Hãy xem:</p>

<pre>
<b>$ git branch</b>
  change_class
* master
<b>$ git merge change_class</b>
Renaming hello.rb => ruby.rb
Auto-merging ruby.rb
Merge made by recursive.
 ruby.rb |    6 ++----
 1 files changed, 2 insertions(+), 4 deletions(-)
<b>$ cat ruby.rb</b>
class HiWorld
  def self.hello
    puts "Hello World from Ruby"
  end
end

HiWorld.hello
</pre>

    <p>Tốt quá, mọi chuyện diễn ra đúng như mong đợi. Như vậy trong quá
    trình trộn ta đã không gặp xung đột nào, kể cả việc đổi tên tập tin
    hoặc đổi tên lớp diễn ra ở nhánh khác</p>

    <h4>
      trộn (giải quyết) xung đột
    </h4>

    <p>Như vậy, Git thật là khéo léo, nhưng ta chưa hề đụng tới trường hợp
      có xung đột. Không sao, khi xảy ra sự khác biệt về mã giữa hai nhánh
      mà Git không thể hình dung được, sẽ tới phiên chúng ta giải quyết.
      Trong ví dụ sau, ta sẽ thay đổi cùng một dòng của tập tin ở hai nhánh.
    <p>

<pre>
<b>$ git branch</b>
* master
<b>$ git checkout -b fix_readme</b>
Switched to a new branch 'fix_readme'
<b>$ vim README </b>
<b>$ git commit -am 'fixed readme title'</b>
[fix_readme 3ac015d] fixed readme title
 1 files changed, 1 insertions(+), 1 deletions(-)
</pre>

    <p>Sau khi rẽ vào nhánh 'fix_readme', ta thực hiện thay đổi một dòng
      trong tập tin 'README'. Tiếp theo ta sẽ thay đổi cùng dòng đó, nhưng
      ở tập tin của nhánh 'master'.</p>

<pre>
<b>$ git checkout master</b>
Switched to branch 'master'
<b>$ vim README </b>
<b>$ git commit -am 'fixed readme title differently'</b>
[master 3cbb6aa] fixed readme title differently
 1 files changed, 1 insertions(+), 1 deletions(-)
</pre>

    <p>Hãy xem có điều thú vị gì xảy ra khi trộn hai tập tin có xung đột
    với nhau:</p>

<pre>
<b>$ git merge fix_readme</b>
Auto-merging README
CONFLICT (content): Merge conflict in README
Automatic merge failed; fix conflicts and then commit the result.
<b>$ cat README </b>
<<<<<<< HEAD
Many Hello World Examples
=======
Hello World Lang Examples
>>>>>>> fix_readme

This project has examples of hello world in
nearly every programming language.
</pre>

    <p>Như bạn thấy, Git chèn vào các ký hiệu đánh dấu sự xung đột xảy
      ra khi trộn. Git đã 'bó tay' khi dừng lại ở đó, và tới phiên bạn
      quyết định. Để ý là,
      <a href="http://www.kernel.org/pub/software/scm/git/docs/git-mergetool.html">một số công cụ đồ họa</a>
      như kdiff3, emerge, p4merge, ... sẽ giúp việc giải quyết xung đột
      dễ dàng hơn.
    </p>

<pre>
<b>$ vim README </b>  <span class="exp"># here I'm fixing the conflict</span>
<b>$ git diff</b>
<span class="umber">diff --cc README
index 9103e27,69cad1a..0000000
--- a/README
+++ b/README</span>
<span class="lblue">@@@ -1,4 -1,4 +1,4 @@@</span>
<span class="red">- Many Hello World Examples</span>
 <span class="red">-Hello World Lang Examples</span>
<span class="green">++Many Hello World Lang Examples</span>

  This project has examples of hello world in
</pre>

    <p>Một mẹo rất hay khi trộn các xung đột trong Git là nếu khi dùng
        <code>git diff</code>,
    chương trình sẽ cho bạn thấy cả hai phần (cũ, mới) gây nên xung đột,
    và cả cách giải quyết xung đột. Sau đó, bạn cần đánh dấu cho tập tin
    rằng xung đột trên nó đã giải quyết xong: bạn sử dụng lệnh
      <code>git add</code>
    và cả <code>git commit</code> để xác nhận.</p>

<pre>
<b>$ git status -s</b>
UU README
<b>$ git add README </b>
<b>$ git status -s</b>
M  README
<b>$ git commit </b>
[master 8d585ea] Merge branch 'fix_readme'
</pre>

    <p>Bây giờ thì xung đột được giải quyết trọn vẹn.</p>

    <p class="nutshell">
    <b>Tóm tắt:</b> bạn dùng <code>git merge</code> để trộn một nhánh với
    nhánh bạn đang rẽ vào. Git sẽ tự động xác định phép trộn tốt nhất để
    có được sản phẩm chung lai giữa hai nhánh.
    </p>

  </div>
</div>

<div class="box">
  <h2>
    <span class="docs">
      <a target="new" href="http://www.kernel.org/pub/software/scm/git/docs/git-log.html">docs</a> &nbsp;
      <a target="new" href="http://progit.org/book/ch6-1.html#commit_ranges">book</a>
    </span>
    <a name="log">git log</a>
    <span class="desc">xem ghi chú về các lần xác nhận</span>
  </h2>

  <div class="block">

    <p>Ta đã biết cách xác nhận các thay đổi, cách chuyển qua lại giữa
    các nhánh. Nhưng chuyện gì xảy ra một khi ta quên mất ta đang ở nhánh
    nào, ở vị trí nào trong một nhánh, hoặc lý do ta rẽ nhánh? Hoặc ta quên
    mất sự khác biệt giữa các nhánh? Lường trước cách trả lời cho cẩu hỏi này,
    Git cung cấp lệnh <code>git log</code> để giúp bạn xem lại mô tả hoặc
    lý do của tất cả các lần xác nhận.</p>

    <p>Truớc khi hiểu về lệnh <code>log</code>, bạn cần biết Git lưu những
    gì mỗi khi bạn xác nhận sự thay đổi bằng lệnh <code>git commit</code>.
    Bên cạnh thông tin về các tập tin, người thay đổi, thông điệp, Git còn
    lưu thông tin về xác nhận có liên quan trực tiếp tới xác nhận đang thực
    hiện. Để hình dung, ta lấy ví dụ: khi bạn nhân bản một dự án, bạn cần
    biết là thay đổi của bạn cho nhân bản đó dựa trên trạng thái nào của dự
    án đã có. Thông tin về trạng thái cũ rất có ích, giúp bạn xác nhận ngữ
    cảnh (nhánh) của bạn và giúp hình dung quá trình phát triển của toàn bộ
    dự án. Bằng cách đặt tên 'cha' (parent) có ngữ cảnh gốc, Git tự động
    biết được bạn làm gì cho ngữ cảnh của bạn (con).
    </p>

    <p>Để xem danh sách các xác nhận 'cha' theo thời gian, bạn dùng lệnh
    <code>git log</code> khi đang ở một nhánh bất kỳ. Ví dụ, kết quả của lệnh
    <code>git log</code> trong dự án HelloWorld ở trên như sau đây.

<pre>
<b>$ git log</b>
<span class="yellow">commit 8d585ea6faf99facd39b55d6f6a3b3f481ad0d3d</span>
Merge: 3cbb6aa 3ac015d
Author: Scott Chacon &lt;schacon@gmail.com>
Date:   Fri Jun 4 12:59:47 2010 +0200

    Merge branch 'fix_readme'

    Conflicts:
        README

<span class="yellow">commit 3cbb6aae5c0cbd711c098e113ae436801371c95e</span>
Author: Scott Chacon &lt;schacon@gmail.com>
Date:   Fri Jun 4 12:58:53 2010 +0200

    fixed readme title differently

<span class="yellow">commit 3ac015da8ade34d4c7ebeffa2053fcac33fb495b</span>
Author: Scott Chacon &lt;schacon@gmail.com>
Date:   Fri Jun 4 12:58:36 2010 +0200

    fixed readme title

<span class="yellow">commit 558151a95567ba4181bab5746bc8f34bd87143d6</span>
Merge: b7ae93b 3467b0a
Author: Scott Chacon &lt;schacon@gmail.com>
Date:   Fri Jun 4 12:37:05 2010 +0200

    Merge branch 'change_class'
...
</pre>

    <p>Để xem kết quả gọn gàng hơn, bạn dùng tùy chọn
    <code>--oneline</code>.</p>

<pre>
<b>$ git log --oneline</b>
8d585ea Merge branch 'fix_readme'
3cbb6aa fixed readme title differently
3ac015d fixed readme title
558151a Merge branch 'change_class'
b7ae93b added from ruby
3467b0a changed the class name
17f4acf first commit
</pre>

    <p>Qua thông tin thu được, ta hình dung được toàn bộ quá trình phát triển
    của nhánh hiện tại (và của dự án). Nếu trong mỗi lần xác nhận, thông điệp
    ta muốn Git lưu lại càng chi tiết thì ta dễ dàng nhớ lại, hình dùng
    tốt về các thay đổi đã thực hiện cũng như ảnh hưởng của nó lên nhánh
    hiện tại..</p>

    <p>Ngoài ra, tùy chọn <code>--graph</code> rất thú vị, khi nó vẽ ra
    một cây phản ánh cấu trúc nhánh của dự án: Kết quả của tùy chọn này
    giải thích tại sao ta dùng từ 'nhánh' để mô tả dự án</p>

<pre>
<b>$ git log --oneline --graph</b>
*   8d585ea Merge branch 'fix_readme'
|\
| * 3ac015d fixed readme title
* | 3cbb6aa fixed readme title differently
|/
*   558151a Merge branch 'change_class'
|\
| * 3467b0a changed the class name
* | b7ae93b added from ruby
|/
* 17f4acf first commit
</pre>

    <p>Minh họa có vẻ đơn sơ trên thực tế giúp bạn hình dung rõ hơn về
    dự án, lý do tạo nhánh và trộn các nhánh, và cũng giúp ích cho việc
    quản lý các nhánh. Sau đây, ta sẽ thử tạo nhánh mới, rẽ vào đó để thực
    hiện vài thay đổi rồi qua lại nhánh chính. Ta sẽ dùng lệnh <code>log</code>
    để hình dung chung về tất cả các nhánh.</p>

    <p>Trước hết, ta tạo và rẽ vào nhánh 'erlang' để có phiên bản của
    chương trình HelloWorld trong ngôn ngữ Erlang. Rõ ràng, ta không nên
    tạo ngay một phiên bản Erlang trong nhánh chính, nếu không thì sau một
    hồi mọi thứ sẽ trở nên lộn xộn, thậm chí là không làm việc được.</p>

<pre>
<b>$ git checkout -b erlang</b>
Switched to a new branch 'erlang'
<b>$ vim erlang_hw.erl</b>
<b>$ git add erlang_hw.erl </b>
<b>$ git commit -m 'added erlang'</b>
[erlang ab5ab4c] added erlang
 1 files changed, 5 insertions(+), 0 deletions(-)
 create mode 100644 erlang_hw.erl
</pre>

    <p>Trong nhánh 'erlang', ta cũng sẽ tạo ra một bản HelloWorl cũng bằng
    ngôn ngữ hàm Haskell.</p>

<pre>
<b>$ vim haskell.hs</b>
<b>$ git add haskell.hs </b>
<b>$ git commit -m 'added haskell'</b>
[erlang 1834130] added haskell
 1 files changed, 4 insertions(+), 0 deletions(-)
 create mode 100644 haskell.hs
</pre>

    <p>Các thay đổi được xác nhận. Bây giờ, ta quyết định quay ngược lại
    phiên bản Ruby để thay đổi tên lớp. Phiên bản Ruby nằm trong nhánh chính,
    vì thế ta cần rẽ vào nhánh đó trước.</p>

<pre>
<b>$ git checkout master</b>
Switched to branch 'master'
<b>$ ls</b>
README  ruby.rb
<b>$ vim ruby.rb </b>
<b>$ git commit -am 'reverted to old class name'</b>
[master 594f90b] reverted to old class name
 1 files changed, 2 insertions(+), 2 deletions(-)
</pre>

    <p>Gỉa sử rằng mọi việc đã xong, bạn quay lại với các công việc khác
    hơn là dự án HelloWorld buồn tẻ. Rồi một ngày khác, quay lại dự án này
    ở nhánh 'master', bạn muốn biết những gì đã diễn ra trên nhánh 'erlang'
    và vị trí trên nhánh chính 'master' mà bạn bắt đầu rẽ vào 'erlang'.
    Nếu chỉ rẽ vào nhánh rồi xem nội dung các tập tin trong nhánh
    đó, hiển nhiên là bạn sẽ không hình dung tại sao lại có phiên bản Haskell
    trong nhánh 'erlang'. Bạn cần phải dùng <code>git log</code> để tìm
    hiểu các lý do; ngoài ra, việc chỉ định tên nhánh sẽ cho biết thông tin
    về điểm rẽ nhánh.</p>

<pre>
<b>$ git log --oneline erlang</b>
<span class="hl">1834130 added haskell</span>
ab5ab4c added erlang
8d585ea Merge branch 'fix_readme'
3cbb6aa fixed readme title differently
3ac015d fixed readme title
558151a Merge branch 'change_class'
b7ae93b added from ruby
3467b0a changed the class name
17f4acf first commit
</pre>

    <p>Từ kết quả trên, dễ thấy là phiên bản Haskell chỉ bắt đầu xuất hiện trong nhánh
      'erlang' (được tô màu ở trên). Nhưng <code>git log</code> còn ghi ra
      nhiều thông tin ở trước thời điểm nhánh 'erlang' được tạo ra.
      Quá nhiều! Điều tuyệt vời là Git đã tính tới phàn nàn này: bạn có thể
      chỉ định Git đưa các thông tin chỉ có ở nhánh này mà không xuất hiện
      ở nhánh khác. Điều này rất có ích, chẳng hạn khi bạn muốn trộn nhánh
      'erlang' vào nhánh 'master', nhưng trước khi trộn, bạn cần biết
      những gì sẽ diễn ra khi trộn.
    </p>

    <p>
      Để không liệt kê các thông tin không cần thiết của một nhánh, bạn
      dùng dấu mũ <code>^</code> trước tên nhánh. Ví dụ, nếu chỉ muốn xem
      các thay đổi trong nhánh 'erlang', bỏ đi các thay đổi trong nhánh
      'master', chỉ việc dùng <code>erlang ^master</code>:
    </p>

<pre>
<b>$ git log --oneline erlang ^master</b>
1834130 added haskell
ab5ab4c added erlang
<b>$ git log --oneline master ^erlang</b>
594f90b reverted to old class name
</pre>

    <p>Sử dụng dấu mũ là một cách đơn giản, hiểu quả khi quản lý các nhánh,
      cho phép bạn thấy được những cái chỉ có ở nhánh này mà không có ở
      nhánh khác. Nhờ đó, bạn kiểm soát các thiếu sót hoặc hình dung
      được những thay đổi khi trộn các nhánh.
    </p>

    <p class="nutshell">
    <b>Tóm tắt:</b> bạn dùng <code>git log</code> để liệt kê thông tin về
    các lần xác nhận sự thay đổi mã nguồn hoặc các lý do của việc rẽ nhánh,
    nhờ đó giúp bạn hình dung quá trình phát triển và trạng thái hiện tại
    của dự án.
    </p>

  </div>
</div>

<div class="box">
  <h2>
    <span class="docs">
      <a target="new" href="http://www.kernel.org/pub/software/scm/git/docs/git-tag.html">docs</a> &nbsp;
      <a target="new" href="http://progit.org/book/ch2-6.html">book</a>
    </span>
    <a name="tag">git tag</a>
    <span class="desc">đánh dấu thời điểm quan trọng trong quá trình phát triển</span>
  </h2>

  <div class="block">

    <p>
    Có một số thời điểm quan trọng trong quá trình phát triển dự án mà
    bạn muốn ghi nhớ một cách dễ dàng và dài lâu. Chúng được đánh dấu
    bằng lệnh <code>git tag</code>: lệnh này đánh dấu ở một điểm trên nhánh
    để bạn có thể dễ dàng so sánh với các xác nhận khác trong tương lai.
    Thường thì bạn sẽ dùng 'tag' (thẻ) khi đưa ra một phiên bản của dự án.
    </p>

    <p>Ví dụ, ta muốn công bố phiên bản "1.0" của chương trình HelloWorld.
    Ta có đánh dấu sự thay đổi cuối cùng (<code>HEAD</code>) là "v1.0" bằng
    lệnh <code>git tag -a v1.0</code>. Tùy chọn <code>-a</code> cho phép
    bạn thêm chú thích cho thẻ "v1.0". Mặc dù việc không dùng tùy chọn đó
    cũng có tác dụng đánh dấu, nhưng kết quả là thông tin về thời điểm đánh
    dấu, tác giả, các ghi chú bổ sung sẽ không được lưu lại. Vì vậy,
    bạn luôn nên dùng tùy chọn <code>-a</code>.</p>

<pre>
<b>$ git tag -a v1.0 </b>
</pre>

  <p>Sau lệnh <code>git tag -a</code> như trên, Git sẽ mở ra trình sọan thảo
    để bạn bắt đầu ghi thông tin chi tiết về thẻ.</p>

  <p>Sau đó, sử dụng lệnh <code>git log --decorate</code>, ngoài các thông
  tin về những lần xác nhận, bạn còn thấy thêm thông tin về các thẻ.</p>

<pre>
<b>$ git log --oneline --decorate --graph</b>
* 594f90b (HEAD, <span class="hl">tag: v1.0</span>, master) reverted to old class name
*   8d585ea Merge branch 'fix_readme'
|\
| * 3ac015d (fix_readme) fixed readme title
* | 3cbb6aa fixed readme title differently
|/
*   558151a Merge branch 'change_class'
|\
| * 3467b0a changed the class name
* | b7ae93b added from ruby
|/
* 17f4acf first commit
</pre>

  <p>Nếu sau khi đánh dấu, bạn xác nhận thêm các thay đổi, thẻ vẫn giữ
    nguyên vị trí ở lần nó tạo ra lần đầu tiên. Như vậy, thẻ được đánh dấu
    sẽ cố định và có thể dùng để so sánh với các trạng thái mới của dự án
    trong tương lai.</p>

  <p>Việc đánh dấu cho các thay đổi hiển nhiên không phải là điều bắt buộc.
    Có thể xảy ra việc bạn đã công bố một phiên bản của dự án mà không (quên)
    đánh dấu. Khi đó, nếu muốn bổ sung đánh dấu, bạn cũng dùng lệnh <code>git tag</code>,
    nhưng đi kèm với chỉ số của xác nhận. Ví dụ, ta sẽ đánh dấu cho xác
    nhận mang chỉ số <code>558151a</code> như sau đây:</p>

<pre>
<b>$ git tag -a v0.9 558151a</b>
<b>$ git log --oneline --decorate --graph</b>
* 594f90b (HEAD, tag: v1.0, master) reverted to old class name
*   8d585ea Merge branch 'fix_readme'
|\
| * 3ac015d (fix_readme) fixed readme title
* | 3cbb6aa fixed readme title differently
|/
*   558151a (<span class="hl">tag: v0.9</span>) Merge branch 'change_class'
|\
| * 3467b0a changed the class name
* | b7ae93b added from ruby
|/
* 17f4acf first commit
</pre>

  </div>
</div>

<p><a href="/remotes">Chia sẻ và Cập nhật dự án &#187;</a></p>

